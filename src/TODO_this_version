--------------------------------------------------
--------------top bar menu----------

*en alguna ocasión no se desactiva topbar, se queda siempre visible aunque estemos en el Basic y con el foco ahí.
->quizá es culpa del autoframeskip?

*menus de topbar deben salir con traducción también? aunque ocupará mas caracteres...

----------Fin top bar menu----------
----------------------------------------


-Agregar ¿todas? las entradas de menus de indexación, llamando a menu_add_item_menu_index_full_path, ejemplo:
        menu_add_item_menu_index_full_path(array_menu_settings_debug,
            "Main Menu-> Settings-> Debug","Menú Principal-> Opciones-> Debug","Menú Principal-> Opcions-> Debug");
Los menus que no usen menu_add_item_menu_index_full_path se les genera automáticamente, si se han abierto desde Main Menu se le agrega ese prefijo,
pero otros que vienen por ejemplo desde Top Menu o desde Top Buttons pues no

-Juego de la vida que tenga ayuda con las reglas del juego. O ya lo tiene?


-Si conmuto de un CPU step a ventana abierta de hexedit, ejecutará alguna instrucción sin querer?
Y teniendo el stop emulation on menú? Se ejecuta alguna instrucción sin querer?


-algun tipo de build que no sea ni linux ni mac ni windows, sino simplemente UNIX_GENERIC o algo similar
Probar mas sistemas unix alternativos



-Ayuda para algunos tipos de iconos o acciones, como send keys menú: send keys por ejemplo tiene el caracter "@" que indica tecla ESC

ok -sendkeys menu poder simular envio ESC para hacer que se cierre el menu
->ok con "@"

-Para Minix:
curses enlazar contra -lcurses y no -lncurses
Poder definir otra tecla para abrir el menu, F5 lanza comandos del sistema
Por ejemplo en driver curses defino tecla END como si fuera F5
Parece que curses no tiene soporte para eventos de ratón
setting para compilar con clang


-lightgun
*rutina de Sinclair Action Pack - Side A, del programa principal que detecta posicion y, ponerla como ejempo
en programa aparte, mostrando coordenada y en pantalla
*emulación de otros sistemas opticos, como TROJAN LIGHT PEN (PRO ZX 128 + 2A / 3 +). Ver documento en extras

ok-lightgun: magnum. poder tener margen de mas de 1 scanline (para el acid killer por ejemplo)


-config setting para aymidi_rs232_enabled.v
if (MACHINE_IS_SPECTRUM) nuevo_aymidi_rs232_handle(value); esto no tendria que ser dependiente de ese setting?
desactivado por defecto
con operation wolf de la magnum escribe muchos mensajes en consola (paranoid) aun desactivando el settting.
Es necesario tanto print?


-poder hacer que con menu abierto, se envien eventos de teclado, pistola etc a máquina emulada.
Util si estamos en debug cpu y queremos que un juego lea el boton del ratón (emulando lightgun) y/o luz de pistola
Quizá con una opción y sólo si está el foco en ventana de debug CPU



-revisar los salir_todos_menus=1 que se puedan cambiar por   menu_add_item_menu_se_cerrara( en el item de menu

-icono para snapshots in ram. Poder guardar snap en ram manualmente, no solo a intervalos.
quiza icono ramdisk que englobe snapshots y otras cosas

-snapshots en ram
*icono para browse snapshots. mejorarlo
*icono para guardar snapshot. mejorarlo

-Soportar uft-8 en el footer, que sirva para texto footer normal pero tambien con opciones de --programsettingsinfo de archivos .config.
*testear con --programname

- Smartload history file: que se guarde en un archivo las rutas de todos los archivos cargados. Me sirve para confeccionar una lista de los juegos a testear en las pruebas de video de ZX80 y ZX81

- Poder ver todos los sprites de tbblue, MSX etc de golpe, en una sola ventana

- Poder ver los t-estados que tarda una instrucción, en vista de debug cpu

-Acción de ESCMenu en joystick, cierra todos los menús? Quizá hay que crear una acción nueva que sea menú atrás... O sirve con mover a la izquierda?

------

#####  Cambio rutinas video ZX80/81: hsync_generator_active.v no se usaba para nada
Y tiempos para hsync y nmi se basan en t-estados y en alterar t-estados artificialmente, esto no es correcto

-view variables interfiere en render!! con breakout por ejemplo
-revisar tscaline_draw_timeout para que funcione modo fast en negro, con modo no-realvideo
-franjas grabacion save no aparecen bien. probablemente por gestion de hsync timeout o vsync timeout
si se activa simular vsync, se ven franjas de grabacion
quiza es que al grabar, la señal de vsync "artificial" (generada de sacar los 0/1 al casette) no es correcta y por eso no engancha vsync nunca
-tiene sentido simulate_lost_hsync?

Info video:

https://quix.us/timex/rigter/ZX@20Video@20Tutorial.html

https://8bit-museum.de/heimcomputer-2/sinclair/sinclair-scans/scans-zx81-video-display-system/

http://blog.tynemouthsoftware.co.uk/2023/10/how-the-zx81-generates-video.html

http://www.fruitcake.plus.com/Sinclair/ZX80/FlickerFree/ZX80_DisplayMechanism.htm

http://searle.x10host.com/zx80/zx80nmiV3.html

https://k1.spdns.de/Vintage/Sinclair/80/Sinclair%20ZX81/ROMs/zx81%20version%202%20%27improved%27%20rom%20source.htm


VSYNC es realmente secuencia de señal vsync + pulsos hsync. como envia esto el ZX81 realmente?
Parece que durante vsync no envia hsync, como se deberia esperar


-Ver rom rutinas nmi y tiempos
http://blog.tynemouthsoftware.co.uk/2023/10/how-the-zx81-generates-video.html
/Wait is also pulled low, to ensure the Z80 is in the correct T-State when the NMI is serviced.
This is gated by the /Halt signal, which would always be high as that is normally triggered by processing
the End of Line character, which will not happen on the non-visible lines.


https://k1.spdns.de/Vintage/Sinclair/80/Sinclair%20ZX81/ROMs/zx81%20version%202%20%27improved%27%20rom%20source.htm
En especial:

HALT                    ; (1) HALT synchronizes with NMI.
; Used with special hardware connected to the
; Z80 HALT and WAIT lines to take 1 clock cycle.


->le pongo que cada halt tarde 1 t-estado cuando se ha lanzado nmi


---

-Ajustar menu settings->TV para al menos una opción? O que no salga si la máquina emulada no tiene opciones
-Meter ajustes de TV (hsync internal frequency-para timeout, vsync internal frequency-para timeout) y otros, en menú settings-Tv

Estado video zx81:
-modo fast: error
-juegos sin efectos hires: ok
-wrx: ok
-chrs128: ok
-hrg: ok
-udg: ok. aunque interc-u.o raro al principio. quizá usa fast?
-pseudo hi res: manic mal. pacman en el juego mal. tetrishr mal

-nolimits.81: inicio mal. posiblemente use combinacion de fast
-sllc.81: falta un scanline de cada char?

->si en todas las condiciones de MACHINE_IS_ZX81_TYPE o MACHINE_IS_ZX80_TYPE uso una macro que es:
#define MACHINE_ZX81_LIKE_ZX80 (MACHINE_IS_ZX81_TYPE && nmi_generator_active.v==0)
para que actue ZX81 como ZX80, funciona bien modo fast.
pero luego manic se ve mal , igual que pacman y tetrishr

fast: quitando el t_estados +=3; de la maskable y lo que el halt dure 1 estado, mejora pero se mueve en horizontal (problema con el lanzamiento de vsync o hsync???)


ajustar esto:

    //Para que la imagen esté centrada. En slow:
    ula_zx81_time_event_t_estados=screen_total_borde_izquierdo;

    //En fast:
    ula_zx81_time_event_t_estados=0;

    //temporal. valor algo arbitrario
    ula_zx81_time_event_t_estados=screen_total_borde_izquierdo/2;

    ula_zx81_time_event_t_estados=16;

-temblor de mazogs quiza es porque el line counter no siempre se pone a 0 en el mismo momento

-borrar los temp_ajuste de F3 y F4 cuando no hagan falta


-temp_llegado_vsync. Parche feo. Lo que deberia hacerse es que no entrase esa primera linea de basura (Manic miner, pacman etc)
O quiza es que está todo desplazado 1 scanline, fijarse que manic miner muestra una linea al final de basura tambien
Corregir tambien el valor arbitrario de ula_zx81_time_event_t_estados en zx8081_out_any_port_video_stuff

-quiza reg_r no se incrementa al generar interrupción??. afecta esto al timing realmente de ZX8081?
-parece que zxsp dispara la interrupción del reg_r despues que haya tenido valor 81h. Supuestamente:
INT                     Reading an opcode when refresh register R.D6=0 triggers an interrupt immediately after this M1 cycle.
-comprobar de nuevo cuantos t-estados se incrementan con interrupcion maskable. 13 tiene ZXSP. 7 tiene Fuse. Yo hago 4

zxsp. desde dec c hasta dec c
37650
37857
=207

zesarux
35334
35550
=216

-Supuestamente ZX80 ya están bien los timings. desde dec c a dec c salta 207. corregidos t-estados al disparar interrupcion
y punto de salto de interrupción al cambiar bit 6 de reg r
En teoria quedaria ajustar timing de nmi para ZX81 y validar todo en ZX81:

NMI and WAIT

NMI is enabled by OUT(FE) and disabled by OUT(FD).

If NMI is enabled, then NMI is active at the same time as the HSYNC pulse.
IF NMI is raised early enough during an OUT(FD) instruction then the NMI is still accepted after the instruction.
It must be active 1cc before the end of the instruction. but it is in a race condition with the HSYNC output which
toggles at full cc. The HSYNC counter output runs through some gates which combine into the HSYNC signal, so it
probably toggles after /NMI is tested by the CPU. Therefore the HSYNC must go active at instruction_end-2cc to be seen.

If NMI is active then WAIT is active at the same time, except if HALT is true during HALT opcode repetitions.
This applies to opcode fetch, memory read & write, input, output, NMIACK and INTACK (IO cycle and pushes).
The waitmap scheme is normal, not like the Sinclair ZX Spectrum with many superfluous wait cycles e.g. in 'jr'.
WAIT is tested at cc+1.5 in memory and cc+2.5 in io access. Therefore it must be asserted at cc+1 or cc+2 respectively.
WAIT is tested at cc+3.5 in INT acknowledge cycle.
WAIT is tested at cc+1.5 in NMI acknowledge cycle. (as in any opcode fetch cycle)
->creo que el problema es que la nmi no se lanza siempre cuando la hsync, sino algún ciclo mas tarde, dependiendo de un waitmap
esto no aplica si está en halt (/* ZX81 has a waitmap for /WAIT during /NMI             */
/* but /WAIT is suppressed if /HALT is active.  */)=
al disparar nmi:

#define GET_INSTR_FOR_NMI()                       \
  do {                                            \
        cc_nmi     = machine->nmiAtCycle(cc);         \
        PgInfo& pg = getPage(pc);                     \
        z32                = pg.both_r(pc) & options;         \
        if (z32 & cpu_waitmap) { CC_WAIT_R(cc + 2); } \
        cc += 5;                                      \
        r += 1;                                       \
  }
#define CC_WAIT_R(CC) cc += pg.waitmap_r[(CC) % pg.waitmap_r_size]


void UlaZx81::setup_waitmap(int32 cc_hsync)
{
        // when NMI is enabled then /NMI and /WAIT are asserted for 16cc at the same time as HSYNC.
        // the Z80 emulation will use cc % 207 to peek into the waitmap[].
        // the NMI will start at cc_nmi => waitmap[cc_nmi%207 to cc_nmi%207+15] must be set.

        // the waitmap must be updated
        // - when the NMI is enabled
        // - when the cc timebase is shifted in videoFrameEnd()
        // - when the HSYNC generator is restarted in interruptAtCycle()

        cc_hsync += waitmap_size;
        assert(cc_hsync >= 0);
        cc_hsync %= waitmap_size;

        if (waitmap[cc_hsync] == 16) // quick test whether it is already set as required
                return;
        clear_waitmap(); // clear old wait positions

        // circularly fill in 16cc delay for the first cc of the NMI pulse to 1cc for the last:
        int i = 0;
        for (; i < min(int(waitmap_size) - cc_hsync, 16); i++) {
            waitmap[cc_hsync + i] = uint8(16 - i);
        }
        for (; i < 16; i++) {
            waitmap[cc_hsync - int(waitmap_size) + i] = uint8(16 - i);
        }

Mete esos 16 valores pero en cualquier parte del array que tiene total de 207 posiciones
Empezando desde el parametro cc_hsync en adelante. Si llega al final pues volvera al principio

        16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1
}
(waitmap_size=207)

setup_waitmap en:
-reset hsync: setup_waitmap(cc_hsync_next + WAITMAP_POS);
-enable nmi: setup_waitmap(cc_hsync + WAITMAP_POS);
-video frame end: setup_waitmap(cc_hsync + WAITMAP_POS);

static constexpr int32 WAITMAP_POS = +1; // +1 wg. test position in Z80.run()

Ojo que si minimo ya sumamos 1, eso se sumara a los 11 ya que se tienen de nmi y por tanto minimo seran 12? Pero la minima nmi en zxsp ha sido de 11
Dice:
if (cc >= cc_nmi) // timing: 4+1,3,3

ese +1 ya es de la tabla. por tanto de base deberiamos considerar 10 ciclos, no 11

-Creo igualmente que el tener ese waitmap no hará cambiar el problema del mazogs y demás, que "salta" un scanline a veces al principio
Creo que ese fallo es de alguna otra cosa...
->creo que eso viene siendo que video_zx8081_lcntr=0; no siempre se dispara en el momento perfecto
->o el problema viene de funcion tv_enable_vsync de tv.c, la condicion que hay para zx81. creo que vsync no se está generando en sitio correcto
--> el problema venia porque solo lanza vsync cuando nmi está off. Corregido

cuando hace vsync deberia lanzar hsync tambien?

Acabar de revisar
int zx8081_read_port_a0_low(z80_byte puerto_h)

con void UlaZx81::input(Time now, int32 cc, uint16 addr, uint8& byte, uint8& mask) de zxsp

-Ver si se tiene logica el disparar hsync y el uso de la variable tv_hsync_signal_pending

-Color rojo para zona de vsync no usada: color temporal, al final deberia ser en negro

-Disparo de interrupciones se debería hacer similar a zxsp, que se pueda hacer step :
*opcode
*si se activa nmi o maskable, que se ejecute en el siguiente step

-int ack genera hsync?

-starfigh.81 creo que es muy sensible a timings, si la nmi tarda mas, va muy lento

-en tv_time_event, si hay vsync, deberia hacerse tv_x=0 ?

-liberado_vsync, primer_caracter: parche horroroso para centrar imagen. En ZX80 parece que va bien (o no?),
en ZX81 no : modos fast y slow lo hacen distinto

-Parece que ZX80 genera hsync al hacer ACK de la interrupción, no tiene contador interno para hsync. Por tanto
no deberiamos usar ula_zx80_position_x_testados
En cambio ZX81 si que dispara hsync desde contador, y no desde ACK.
Supuestamente en ZX81: the INTACK (/IORQ & /M1) signal resets the counter of the HSYNC generator
O sea:
-contador ula_zx81_time_event_t_estados no dispara hsync, solo nmi
-en int ack de nmi, generar hsync
-en int ack de no nmi, generar hsync y reset ula_zx81_time_event_t_estados. ver cuando hace hsync el zxsp
Con esto, se ven bien todos excepto WRX y pseudo hi res

diff --git a/src/cores/core_zx8081.c b/src/cores/core_zx8081.c
index 0746a75c..aea83a46 100644
--- a/src/cores/core_zx8081.c
+++ b/src/cores/core_zx8081.c
@@ -430,7 +430,7 @@ void cpu_core_loop_zx8081(void)

     //Interrupcion de cpu. gestion im0/1/2. Esto se hace al cambio de bit6 de R en zx80/81
     if (interrupcion_maskable_generada.v || interrupcion_non_maskable_generada.v) {
-
+extern int pending_disable_hsync;
         debug_fired_interrupt=1;

         z80_adjust_flags_interrupt_block_opcode();
@@ -473,6 +473,16 @@ void cpu_core_loop_zx8081(void)


             //printf("5. nmi %d\n",t_estados);
+
+            if (MACHINE_IS_ZX81_TYPE) {
+                if (hsync_generator_active.v) {
+                    generar_zx81_hsync();
+
+                    //Y desactivamos hsync al momento
+                    pending_disable_hsync=0;
+                    tv_disable_hsync();
+                }
+            }
         }


@@ -550,6 +560,18 @@ void cpu_core_loop_zx8081(void)
                 tv_disable_hsync();
             }

+            if (MACHINE_IS_ZX81_TYPE) {
+                if (hsync_generator_active.v) {
+                    generar_zx81_hsync();
+
+                    //Y desactivamos hsync al momento
+                    pending_disable_hsync=0;
+                    tv_disable_hsync();
+                }
+
+                ula_zx81_time_event_t_estados=0;
+            }
+
         }


diff --git a/src/machines/zx8081.c b/src/machines/zx8081.c
index c34c4404..c09ef7f6 100644
--- a/src/machines/zx8081.c
+++ b/src/machines/zx8081.c
@@ -775,13 +775,13 @@ void ula_zx81_time_event(int delta)
                 generate_nmi();
             }

-            if (hsync_generator_active.v) {
+            /*if (hsync_generator_active.v) {
                 generar_zx81_hsync();

                 //Y desactivamos hsync al momento
                 pending_disable_hsync=0;
                 tv_disable_hsync();
-            }
+            }*/
             /*
             Al generar nmi,
             /Wait is also pulled low, to ensure the Z80 is in the correct T-State when the NMI is serviced.
@@ -949,7 +949,7 @@ void zx8081_out_any_port_video_stuff(void)
     //temporal. valor algo arbitrario
     //ula_zx81_time_event_t_estados=screen_total_borde_izquierdo/2;

-    ula_zx81_time_event_t_estados=16;
+    //ula_zx81_time_event_t_estados=16;


     tv_disable_vsync();
diff --git a/src/tv.c b/src/tv.c
index d0191035..3aabf4be 100644
--- a/src/tv.c
+++ b/src/tv.c
@@ -101,6 +101,8 @@ void tv_time_event_store_chunk_image(int delta)
         //asi estaria hsync activo todo ese tiempo (tiempo screen_invisible_borde_derecho) y al liberarlo, la tv_x seria 0
         if (MACHINE_IS_ZX80_TYPE) xorig -=screen_invisible_borde_derecho;

+        if (MACHINE_IS_ZX81_TYPE) xorig -=screen_invisible_borde_derecho;
+
         int xmax=xorig+delta*2;

         int totalancho=get_total_ancho_rainbow();
iMac-de-Cesar:src cesarhernandez$


-ZX81 parece en manic miner y en demos WRX que usaria metodo de hsync por registro R (ACK) pero las interrupciones están deshabilitadas
Por tanto seguramente la hsync se lance siempre desde contador
Cuando se hace out, ula_zx81_time_event_t_estados=16 esto no está bien...
Quiza problema con halt y los t_estados que tarda...
O quiza el problema viene de vsync. Jugar a cambiar ula_zx81_time_event_t_estados al inicio de vsync o al final