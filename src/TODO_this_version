--------------------------------------------------
--------------top bar menu----------

*en alguna ocasión no se desactiva topbar, se queda siempre visible aunque estemos en el Basic y con el foco ahí.
->quizá es culpa del autoframeskip?

*menus de topbar deben salir con traducción también? aunque ocupará mas caracteres...

----------Fin top bar menu----------
----------------------------------------


-Agregar ¿todas? las entradas de menus de indexación, llamando a menu_add_item_menu_index_full_path, ejemplo:
        menu_add_item_menu_index_full_path(array_menu_settings_debug,
            "Main Menu-> Settings-> Debug","Menú Principal-> Opciones-> Debug","Menú Principal-> Opcions-> Debug");
Los menus que no usen menu_add_item_menu_index_full_path se les genera automáticamente, si se han abierto desde Main Menu se le agrega ese prefijo,
pero otros que vienen por ejemplo desde Top Menu o desde Top Buttons pues no

-Juego de la vida que tenga ayuda con las reglas del juego. O ya lo tiene?


-Si conmuto de un CPU step a ventana abierta de hexedit, ejecutará alguna instrucción sin querer?
Y teniendo el stop emulation on menú? Se ejecuta alguna instrucción sin querer?


-algun tipo de build que no sea ni linux ni mac ni windows, sino simplemente UNIX_GENERIC o algo similar
Probar mas sistemas unix alternativos



-Ayuda para algunos tipos de iconos o acciones, como send keys menú: send keys por ejemplo tiene el caracter "@" que indica tecla ESC

ok -sendkeys menu poder simular envio ESC para hacer que se cierre el menu
->ok con "@"

-Para Minix:
curses enlazar contra -lcurses y no -lncurses
Poder definir otra tecla para abrir el menu, F5 lanza comandos del sistema
Por ejemplo en driver curses defino tecla END como si fuera F5
Parece que curses no tiene soporte para eventos de ratón
setting para compilar con clang


-lightgun
*rutina de Sinclair Action Pack - Side A, del programa principal que detecta posicion y, ponerla como ejempo
en programa aparte, mostrando coordenada y en pantalla
*emulación de otros sistemas opticos, como TROJAN LIGHT PEN (PRO ZX 128 + 2A / 3 +). Ver documento en extras

ok-lightgun: magnum. poder tener margen de mas de 1 scanline (para el acid killer por ejemplo)


-config setting para aymidi_rs232_enabled.v
if (MACHINE_IS_SPECTRUM) nuevo_aymidi_rs232_handle(value); esto no tendria que ser dependiente de ese setting?
desactivado por defecto
con operation wolf de la magnum escribe muchos mensajes en consola (paranoid) aun desactivando el settting.
Es necesario tanto print?


-poder hacer que con menu abierto, se envien eventos de teclado, pistola etc a máquina emulada.
Util si estamos en debug cpu y queremos que un juego lea el boton del ratón (emulando lightgun) y/o luz de pistola
Quizá con una opción y sólo si está el foco en ventana de debug CPU



-revisar los salir_todos_menus=1 que se puedan cambiar por   menu_add_item_menu_se_cerrara( en el item de menu

-icono para snapshots in ram. Poder guardar snap en ram manualmente, no solo a intervalos.
quiza icono ramdisk que englobe snapshots y otras cosas

-snapshots en ram
*icono para browse snapshots. mejorarlo
*icono para guardar snapshot. mejorarlo

-Soportar uft-8 en el footer, que sirva para texto footer normal pero tambien con opciones de --programsettingsinfo de archivos .config.
*testear con --programname

- Smartload history file: que se guarde en un archivo las rutas de todos los archivos cargados. Me sirve para confeccionar una lista de los juegos a testear en las pruebas de video de ZX80 y ZX81

- Poder ver todos los sprites de tbblue, MSX etc de golpe, en una sola ventana

- Poder ver los t-estados que tarda una instrucción, en vista de debug cpu

-Acción de ESCMenu en joystick, cierra todos los menús? Quizá hay que crear una acción nueva que sea menú atrás... O sirve con mover a la izquierda?

------

#####  Cambio rutinas video ZX80/81: hsync_generator_active.v no se usaba para nada
Y tiempos para hsync y nmi se basan en t-estados y en alterar t-estados artificialmente, esto no es correcto

-view variables interfiere en render!! con breakout por ejemplo
-revisar tscaline_draw_timeout para que funcione modo fast en negro, con modo no-realvideo
-franjas grabacion save no aparecen bien. probablemente por gestion de hsync timeout o vsync timeout
si se activa simular vsync, se ven franjas de grabacion
quiza es que al grabar, la señal de vsync "artificial" (generada de sacar los 0/1 al casette) no es correcta y por eso no engancha vsync nunca
-tiene sentido simulate_lost_hsync?

Info video:

https://quix.us/timex/rigter/ZX@20Video@20Tutorial.html

https://8bit-museum.de/heimcomputer-2/sinclair/sinclair-scans/scans-zx81-video-display-system/

http://blog.tynemouthsoftware.co.uk/2023/10/how-the-zx81-generates-video.html

http://www.fruitcake.plus.com/Sinclair/ZX80/FlickerFree/ZX80_DisplayMechanism.htm

http://searle.x10host.com/zx80/zx80nmiV3.html

https://k1.spdns.de/Vintage/Sinclair/80/Sinclair%20ZX81/ROMs/zx81%20version%202%20%27improved%27%20rom%20source.htm



nmi
ese +1 ya es de la tabla. por tanto de base deberiamos considerar 10 ciclos, no 11

-Creo igualmente que el tener ese waitmap no hará cambiar el problema del mazogs y demás, que "salta" un scanline a veces al principio
Creo que ese fallo es de alguna otra cosa...
->creo que eso viene siendo que video_zx8081_lcntr=0; no siempre se dispara en el momento perfecto
->o el problema viene de funcion tv_enable_vsync de tv.c, la condicion que hay para zx81. creo que vsync no se está generando en sitio correcto
--> el problema venia porque solo lanza vsync cuando nmi está off. Corregido

cuando hace vsync deberia lanzar hsync tambien?

Acabar de revisar
int zx8081_read_port_a0_low(z80_byte puerto_h)

con void UlaZx81::input(Time now, int32 cc, uint16 addr, uint8& byte, uint8& mask) de zxsp

-Ver si se tiene logica el disparar hsync y el uso de la variable tv_hsync_signal_pending

-Color rojo para zona de vsync no usada: color temporal, al final deberia ser en negro

-Disparo de interrupciones se debería hacer similar a zxsp, que se pueda hacer step :
*opcode
*si se activa nmi o maskable, que se ejecute en el siguiente step

-int ack genera hsync?

-starfigh.81 creo que es muy sensible a timings, si la nmi tarda mas, va muy lento

-en tv_time_event, si hay vsync, deberia hacerse tv_x=0 ?

-liberado_vsync, primer_caracter: parche horroroso para centrar imagen. En ZX80 parece que va bien (o no?),
en ZX81 no : modos fast y slow lo hacen distinto

-Parece que ZX80 genera hsync al hacer ACK de la interrupción, no tiene contador interno para hsync. Por tanto
no deberiamos usar ula_zx80_position_x_testados
En cambio ZX81 si que dispara hsync desde contador, y no desde ACK.
Supuestamente en ZX81: the INTACK (/IORQ & /M1) signal resets the counter of the HSYNC generator
O sea:
-contador ula_zx81_time_event_t_estados no dispara hsync, solo nmi
-en int ack de nmi, generar hsync
-en int ack de no nmi, generar hsync y reset ula_zx81_time_event_t_estados. ver cuando hace hsync el zxsp
Con esto, se ven bien todos excepto WRX y pseudo hi res

diff --git a/src/cores/core_zx8081.c b/src/cores/core_zx8081.c
index 0746a75c..aea83a46 100644
--- a/src/cores/core_zx8081.c
+++ b/src/cores/core_zx8081.c
@@ -430,7 +430,7 @@ void cpu_core_loop_zx8081(void)

     //Interrupcion de cpu. gestion im0/1/2. Esto se hace al cambio de bit6 de R en zx80/81
     if (interrupcion_maskable_generada.v || interrupcion_non_maskable_generada.v) {
-
+extern int pending_disable_hsync;
         debug_fired_interrupt=1;

         z80_adjust_flags_interrupt_block_opcode();
@@ -473,6 +473,16 @@ void cpu_core_loop_zx8081(void)


             //printf("5. nmi %d\n",t_estados);
+
+            if (MACHINE_IS_ZX81_TYPE) {
+                if (hsync_generator_active.v) {
+                    generar_zx81_hsync();
+
+                    //Y desactivamos hsync al momento
+                    pending_disable_hsync=0;
+                    tv_disable_hsync();
+                }
+            }
         }


@@ -550,6 +560,18 @@ void cpu_core_loop_zx8081(void)
                 tv_disable_hsync();
             }

+            if (MACHINE_IS_ZX81_TYPE) {
+                if (hsync_generator_active.v) {
+                    generar_zx81_hsync();
+
+                    //Y desactivamos hsync al momento
+                    pending_disable_hsync=0;
+                    tv_disable_hsync();
+                }
+
+                ula_zx81_time_event_t_estados=0;
+            }
+
         }


diff --git a/src/machines/zx8081.c b/src/machines/zx8081.c
index c34c4404..c09ef7f6 100644
--- a/src/machines/zx8081.c
+++ b/src/machines/zx8081.c
@@ -775,13 +775,13 @@ void ula_zx81_time_event(int delta)
                 generate_nmi();
             }

-            if (hsync_generator_active.v) {
+            /*if (hsync_generator_active.v) {
                 generar_zx81_hsync();

                 //Y desactivamos hsync al momento
                 pending_disable_hsync=0;
                 tv_disable_hsync();
-            }
+            }*/
             /*
             Al generar nmi,
             /Wait is also pulled low, to ensure the Z80 is in the correct T-State when the NMI is serviced.
@@ -949,7 +949,7 @@ void zx8081_out_any_port_video_stuff(void)
     //temporal. valor algo arbitrario
     //ula_zx81_time_event_t_estados=screen_total_borde_izquierdo/2;

-    ula_zx81_time_event_t_estados=16;
+    //ula_zx81_time_event_t_estados=16;


     tv_disable_vsync();
diff --git a/src/tv.c b/src/tv.c
index d0191035..3aabf4be 100644
--- a/src/tv.c
+++ b/src/tv.c
@@ -101,6 +101,8 @@ void tv_time_event_store_chunk_image(int delta)
         //asi estaria hsync activo todo ese tiempo (tiempo screen_invisible_borde_derecho) y al liberarlo, la tv_x seria 0
         if (MACHINE_IS_ZX80_TYPE) xorig -=screen_invisible_borde_derecho;

+        if (MACHINE_IS_ZX81_TYPE) xorig -=screen_invisible_borde_derecho;
+
         int xmax=xorig+delta*2;

         int totalancho=get_total_ancho_rainbow();
iMac-de-Cesar:src cesarhernandez$


-ZX81 parece en manic miner y en demos WRX que usaria metodo de hsync por registro R (ACK) pero las interrupciones están deshabilitadas
Por tanto seguramente la hsync se lance siempre desde contador
Cuando se hace out, ula_zx81_time_event_t_estados=16 esto no está bien...
Quiza problema con halt y los t_estados que tarda...
O quiza el problema viene de vsync. Jugar a cambiar ula_zx81_time_event_t_estados al inicio de vsync o al final
hsync generator no se puede desactivar?

Quiza en zx8081_out_any_port_video_stuff cambiar ula_zx81_time_event_t_estados=16; solo cuando está zx8081_vsync_generator.v
Esto permite hacer ese ajuste solo cuando hay el primer vsync a principio de frame



When an interrupt is accepted by the CPU it activates M1 and IORQ simultaneously, which is called the INTACK.
mal-> This condition resets the HSYNC counter.


-Revisar franjas de load y save

-revisar waitmap y activarlo en pausa nmi. o dejar el 9 tal cual. si no se usa, desactivar funciones de uso de waitmap (no estoy
seguro de que alguna vez se salga de rango y genere segfault)

-Revisar settings de config y custom file config de ZX80 y ZX81 que ya no se usen. Dejarlas como deprecated